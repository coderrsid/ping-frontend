{"ast":null,"code":"import { useState, useEffect } from \"react\";\nimport axios from 'axios';\nimport { pushNotificationData } from './UserFunctions';\nimport { isPushNotificationSupported, askUserPermission, registerServiceWorker, createNotificationSubscription, getUserSubscription } from \"./push-notifications\";\nimport jwt_decode from 'jwt-decode'; //import all the function created to manage the push notifications\n\nconst pushNotificationSupported = isPushNotificationSupported(); //first thing to do: check if the push notifications are supported by the browser\n\nexport default function usePushNotifications() {\n  const [userConsent, setSuserConsent] = useState(Notification.permission); //to manage the user consent: Notification.permission is a JavaScript native function that return the current state of the permission\n  //We initialize the userConsent with that value\n\n  const [userSubscription, setUserSubscription] = useState(null); //to manage the use push notification subscription\n\n  const [pushServerSubscriptionId, setPushServerSubscriptionId] = useState(); //to manage the push server subscription\n\n  const [error, setError] = useState(null); //to manage errors\n\n  const [loading, setLoading] = useState(true); //to manage async actions\n\n  useEffect(() => {\n    if (pushNotificationSupported) {\n      setLoading(true);\n      setError(false);\n      registerServiceWorker().then(() => {\n        setLoading(false);\n      });\n    }\n  }, []); //if the push notifications are supported, registers the service worker\n  //this effect runs only the first render\n\n  useEffect(() => {\n    setLoading(true);\n    setError(false);\n\n    const getExixtingSubscription = async () => {\n      const existingSubscription = await getUserSubscription();\n      setUserSubscription(existingSubscription);\n      setLoading(false);\n    };\n\n    getExixtingSubscription();\n  }, []); //Retrieve if there is any push notification subscription for the registered service worker\n  // this use effect runs only in the first render\n\n  /**\n   * define a click handler that asks the user permission,\n   * it uses the setSuserConsent state, to set the consent of the user\n   * If the user denies the consent, an error is created with the setError hook\n   */\n\n  const onClickAskUserPermission = () => {\n    console.log('asked user permission');\n    setLoading(true);\n    setError(false);\n    askUserPermission().then(consent => {\n      setSuserConsent(consent);\n\n      if (consent !== \"granted\") {\n        alert('Please grant permission for remainders');\n      } else {\n        console.log('subscibed1');\n        onClickSusbribeToPushNotification();\n      }\n\n      setLoading(false);\n    });\n  }; //\n\n  /**\n   * define a click handler that creates a push notification subscription.\n   * Once the subscription is created, it uses the setUserSubscription hook\n   */\n\n\n  const onClickSusbribeToPushNotification = () => {\n    setLoading(true);\n    setError(false);\n    createNotificationSubscription().then(function (subscrition) {\n      setUserSubscription(subscrition);\n      console.log(subscrition);\n      onClickSendSubscriptionToPushServer(subscrition);\n      setLoading(false);\n      console.log('subscibed2');\n    }).catch(err => {\n      console.error(\"Couldn't create the notification subscription\", err, \"name:\", err.name, \"message:\", err.message, \"code:\", err.code);\n      setError(err);\n      setLoading(false);\n    });\n  };\n  /**\n   * define a click handler that sends the push susbcribtion to the push server.\n   * Once the subscription ics created on the server, it saves the id using the hook setPushServerSubscriptionId\n   */\n\n\n  const onClickSendSubscriptionToPushServer = subscription => {\n    setLoading(true);\n    setError(false);\n    const token = localStorage.usertoken;\n    const decoded = jwt_decode(token);\n    console.log(subscription);\n    setPushServerSubscriptionId(subscription);\n    subscription = JSON.stringify(subscription);\n    pushNotificationData(decoded.identity.id, subscription);\n  };\n  /**\n   * define a click handler that requests the push server to send a notification, passing the id of the saved subscription\n   */\n\n\n  const onClickSendNotification = async () => {\n    setLoading(true);\n    setError(false);\n    await axios.get(`/subscription/${pushServerSubscriptionId}`).catch(err => {\n      setLoading(false);\n      setError(err);\n    });\n    setLoading(false);\n  };\n  /**\n   * returns all the stuff needed by a Component\n   */\n\n\n  return {\n    onClickAskUserPermission,\n    onClickSusbribeToPushNotification,\n    onClickSendSubscriptionToPushServer,\n    pushServerSubscriptionId,\n    onClickSendNotification,\n    userConsent,\n    pushNotificationSupported,\n    userSubscription,\n    error,\n    loading\n  };\n}","map":{"version":3,"sources":["/Users/siddhantsehgal/Desktop/userlogin/client/src/components/usePushNotifications.js"],"names":["useState","useEffect","axios","pushNotificationData","isPushNotificationSupported","askUserPermission","registerServiceWorker","createNotificationSubscription","getUserSubscription","jwt_decode","pushNotificationSupported","usePushNotifications","userConsent","setSuserConsent","Notification","permission","userSubscription","setUserSubscription","pushServerSubscriptionId","setPushServerSubscriptionId","error","setError","loading","setLoading","then","getExixtingSubscription","existingSubscription","onClickAskUserPermission","console","log","consent","alert","onClickSusbribeToPushNotification","subscrition","onClickSendSubscriptionToPushServer","catch","err","name","message","code","subscription","token","localStorage","usertoken","decoded","JSON","stringify","identity","id","onClickSendNotification","get"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\nimport axios from 'axios'\nimport { pushNotificationData } from './UserFunctions';\nimport {\n  isPushNotificationSupported,\n  askUserPermission,\n  registerServiceWorker,\n  createNotificationSubscription,\n  getUserSubscription\n} from \"./push-notifications\";\nimport jwt_decode from 'jwt-decode'\n\n//import all the function created to manage the push notifications\n\nconst pushNotificationSupported = isPushNotificationSupported();\n//first thing to do: check if the push notifications are supported by the browser\n\nexport default function usePushNotifications() {\n  const [userConsent, setSuserConsent] = useState(Notification.permission);\n  //to manage the user consent: Notification.permission is a JavaScript native function that return the current state of the permission\n  //We initialize the userConsent with that value\n  const [userSubscription, setUserSubscription] = useState(null);\n  //to manage the use push notification subscription\n  const [pushServerSubscriptionId, setPushServerSubscriptionId] = useState();\n  //to manage the push server subscription\n  const [error, setError] = useState(null);\n  //to manage errors\n  const [loading, setLoading] = useState(true);\n  //to manage async actions\n\n  useEffect(() => {\n    if (pushNotificationSupported) {\n      setLoading(true);\n      setError(false);\n      registerServiceWorker().then(() => {\n        setLoading(false);\n      });\n    }\n  }, []);\n  //if the push notifications are supported, registers the service worker\n  //this effect runs only the first render\n  \n  useEffect(() => {\n    setLoading(true);\n    setError(false);\n    const getExixtingSubscription = async () => {\n      const existingSubscription = await getUserSubscription();\n      setUserSubscription(existingSubscription);\n      setLoading(false);\n    };\n    getExixtingSubscription();\n  }, []);\n  //Retrieve if there is any push notification subscription for the registered service worker\n  // this use effect runs only in the first render\n\n  /**\n   * define a click handler that asks the user permission,\n   * it uses the setSuserConsent state, to set the consent of the user\n   * If the user denies the consent, an error is created with the setError hook\n   */\n  const onClickAskUserPermission = () => {\n    console.log('asked user permission');\n    setLoading(true);\n    setError(false);\n    askUserPermission().then(consent => {\n      setSuserConsent(consent);\n      if (consent !== \"granted\") {\n        alert('Please grant permission for remainders');\n      } else {\n        console.log('subscibed1');\n        onClickSusbribeToPushNotification();\n      }\n      setLoading(false);\n    });\n  };\n  //\n\n  /**\n   * define a click handler that creates a push notification subscription.\n   * Once the subscription is created, it uses the setUserSubscription hook\n   */\n  const onClickSusbribeToPushNotification = () => {\n    setLoading(true);\n    setError(false);\n    createNotificationSubscription()\n      .then(function(subscrition) {\n        setUserSubscription(subscrition);\n        console.log(subscrition);\n        onClickSendSubscriptionToPushServer(subscrition);\n        setLoading(false);\n        console.log('subscibed2');\n      })\n      .catch(err => {\n        console.error(\"Couldn't create the notification subscription\", err, \"name:\", err.name, \"message:\", err.message, \"code:\", err.code);\n        setError(err);\n        setLoading(false);\n      });\n  };\n\n  /**\n   * define a click handler that sends the push susbcribtion to the push server.\n   * Once the subscription ics created on the server, it saves the id using the hook setPushServerSubscriptionId\n   */\n  const onClickSendSubscriptionToPushServer = (subscription) => {\n    setLoading(true);\n    setError(false);\n    const token = localStorage.usertoken;\n    const decoded = jwt_decode(token);\n    console.log(subscription);\n    setPushServerSubscriptionId(subscription);\n    subscription = JSON.stringify(subscription);\n    pushNotificationData(decoded.identity.id, subscription);\n  };\n\n  /**\n   * define a click handler that requests the push server to send a notification, passing the id of the saved subscription\n   */\n  const onClickSendNotification = async () => {\n    setLoading(true);\n    setError(false);\n    await axios.get(`/subscription/${pushServerSubscriptionId}`).catch(err => {\n      setLoading(false);\n      setError(err);\n    });\n    setLoading(false);\n  };\n\n  /**\n   * returns all the stuff needed by a Component\n   */\n  return {\n    onClickAskUserPermission,\n    onClickSusbribeToPushNotification,\n    onClickSendSubscriptionToPushServer,\n    pushServerSubscriptionId,\n    onClickSendNotification,\n    userConsent,\n    pushNotificationSupported,\n    userSubscription,\n    error,\n    loading\n  };\n}"]},"metadata":{},"sourceType":"module"}